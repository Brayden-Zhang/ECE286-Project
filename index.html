<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memory Recall Experiment</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        
        h1, h2 {
            color: #2c3e50;
        }
        
        .grid-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 20px 0;
        }
        
        .box {
            width: 100%;
            aspect-ratio: 1;
            background-color: #f1f1f1;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .box:hover {
            background-color: #ddd;
        }
        
        .flash {
            background-color: #3498db;
            color: white;
        }
        
        .correct {
            background-color: #2ecc71;
            color: white;
        }
        
        .incorrect {
            background-color: #e74c3c;
            color: white;
        }
        
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            font-size: 16px;
            cursor: pointer;
            margin: 10px 5px 10px 0;
            border-radius: 4px;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        select {
            padding: 8px;
            font-size: 16px;
            margin: 10px 0;
        }
        
        #results {
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 4px;
        }
        
        .hidden {
            display: none;
        }
        
        #familiarityTest {
            margin: 20px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 4px;
        }
        
        audio {
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <h1>Memory Recall Experiment</h1>
    
    <div id="setup">
        <h2>Experiment Setup</h2>
        <div>
            <label for="participantId">Participant ID:</label>
            <input type="text" id="participantId" required>
        </div>
        <div>
            <label for="musicCondition">Music Condition:</label>
            <select id="musicCondition">
                <option value="familiar">Familiar Music</option>
                <option value="unfamiliar">Unfamiliar Music</option>
            </select>
        </div>
        <div>
            <label for="musicalTraining">Prior Musical Training (years):</label>
            <input type="number" id="musicalTraining" min="0" value="0">
        </div>
        
        <div id="familiarityTest" class="hidden">
            <h3>Music Familiarity Test</h3>
            <p>Please listen to the first 3 seconds of this song and indicate if it's familiar to you.</p>
            <div id="audioPlayerContainer">
                <audio id="audioPlayer" controls>
                    <source src="" type="audio/mpeg">
                    Your browser does not support the audio element.
                </audio>
                <button id="stopAfter3Sec">Play 3 seconds</button>
            </div>
            <div>
                <button id="familiar">Yes, I recognize this song</button>
                <button id="unfamiliar">No, I don't recognize this song</button>
            </div>
        </div>
        
        <button id="startTest">Start Test</button>
    </div>
    
    <div id="testArea" class="hidden">
        <h2>Memory Test</h2>
        <div id="audioPlayback" class="hidden">
            <p>Background music is playing. Please do not adjust volume during the test.</p>
            <audio id="backgroundMusic" loop>
                <source src="" type="audio/mpeg">
            </audio>
        </div>
        
        <p id="instructions">Memorize the order of the numbers that will appear.</p>
        <div class="grid-container" id="grid">
            <!-- Boxes will be generated dynamically -->
        </div>
        <p id="feedback"></p>
        <button id="nextLevel" class="hidden">Next Level</button>
        <button id="endTest" class="hidden">End Test</button>
        <button id="quitTest" style="background-color: #e74c3c;">Quit Test</button>
    </div>
    
    <div id="results" class="hidden">
        <h2>Test Results</h2>
        <div id="resultsContent"></div>
        <button id="downloadResults">Download Results</button>
        <button id="newTest">New Test</button>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Add more grid sizes for progressive difficulty
            // Configuration for 4 levels with specific grid sizes and sequence lengths
            const gridSizes = [3, 3, 4, 4]; // Level 1: 3x3, Level 2: 3x3, Level 3: 4x4, Level 4: 4x4
            let currentLevel = 0;
            // Track attempts per level
            let attemptsPerLevel = [0, 0, 0, 0]; // One for each level
            let sequence = [];
            let userSequence = [];
            let isDisplaying = false;
            let isRecalling = false;
            let startTime, endTime;
            let attempts = 0;
            let failures = 0;
            let results = [];
            let musicCondition = 'none';
            let musicFamiliarity = null;
            let wasQuit = false;
            let allLevelsCompleted = false;
            
            // DOM elements
            const setupDiv = document.getElementById('setup');
            const testAreaDiv = document.getElementById('testArea');
            const resultsDiv = document.getElementById('results');
            const gridDiv = document.getElementById('grid');
            const instructionsP = document.getElementById('instructions');
            const feedbackP = document.getElementById('feedback');
            const nextLevelBtn = document.getElementById('nextLevel');
            const endTestBtn = document.getElementById('endTest');
            const familiarityTestDiv = document.getElementById('familiarityTest');
            const audioPlayer = document.getElementById('audioPlayer');
            const stopAfter3Sec = document.getElementById('stopAfter3Sec');
            const backgroundMusic = document.getElementById('backgroundMusic');
            const audioPlayback = document.getElementById('audioPlayback');
            
            // Sample song URLs (you would replace these with your actual song URLs)
            const familiarSongs = [
                'https://example.com/familiar-song1.mp3',
                'https://example.com/familiar-song2.mp3'
            ];
            
            const unfamiliarSongs = [
                'https://example.com/unfamiliar-song1.mp3',
                'https://example.com/unfamiliar-song2.mp3'
            ];
            
            // Event Listeners
            document.getElementById('musicCondition').addEventListener('change', function() {
                musicCondition = this.value;
                if (musicCondition === 'familiar' || musicCondition === 'unfamiliar') {
                    familiarityTestDiv.classList.remove('hidden');
                    // Set a random song for testing
                    const songList = musicCondition === 'familiar' ? familiarSongs : unfamiliarSongs;
                    const randomSong = songList[Math.floor(Math.random() * songList.length)];
                    audioPlayer.src = randomSong;
                } else {
                    familiarityTestDiv.classList.add('hidden');
                }
            });
            
            stopAfter3Sec.addEventListener('click', function() {
                audioPlayer.play();
                setTimeout(() => {
                    audioPlayer.pause();
                    audioPlayer.currentTime = 0;
                }, 3000);
            });
            
            document.getElementById('familiar').addEventListener('click', function() {
                musicFamiliarity = true;
                alert('You indicated the song is familiar to you.');
            });
            
            document.getElementById('unfamiliar').addEventListener('click', function() {
                musicFamiliarity = false;
                alert('You indicated the song is unfamiliar to you.');
            });
            
            document.getElementById('startTest').addEventListener('click', function() {
                const participantId = document.getElementById('participantId').value;
                if (!participantId) {
                    alert('Please enter a Participant ID');
                    return;
                }
                
                if ((musicCondition === 'familiar' && !musicFamiliarity) || 
                    (musicCondition === 'unfamiliar' && musicFamiliarity === true)) {
                    alert('The song familiarity does not match the selected condition. Please select a different song or condition.');
                    return;
                }
                
                // Start background music if applicable
                if (musicCondition !== 'none') {
                    audioPlayback.classList.remove('hidden');
                    backgroundMusic.src = audioPlayer.src;
                    backgroundMusic.play();
                }
                
                // Hide setup, show test area
                setupDiv.classList.add('hidden');
                testAreaDiv.classList.remove('hidden');
                
                // Start the first level
                startLevel();
            });
            
            // Update the event listeners section
            // Add event listener for the quit button
            document.getElementById('quitTest').addEventListener('click', function() {
                if (confirm('Are you sure you want to quit the test? Your current progress will be saved.')) {
                    // Ensure we have at least one result before ending the test
                    if (results.length === 0) {
                        // Create a minimal result entry to ensure we have something to save
                        results.push({
                            participantId: document.getElementById('participantId').value,
                            musicalTraining: parseInt(document.getElementById('musicalTraining').value) || 0,
                            musicCondition: musicCondition,
                            level: currentLevel + 1,
                            gridSize: gridSizes[currentLevel],
                            sequenceLength: sequence.length,
                            responseTime: 0,
                            accuracy: 0,
                            attempt: 1,
                            timestamp: new Date().toISOString()
                        });
                    }
                    
                    // Call endTest with quit=true
                    endTest(true);
                }
            });
            
            nextLevelBtn.addEventListener('click', function() {
                currentLevel++;
                if (currentLevel < gridSizes.length) {
                    startLevel();
                } else {
                    // End of test - all levels completed
                    endTest(false, true); // Pass true as second param to indicate completion
                }
            });
            
            endTestBtn.addEventListener('click', endTest);
            
            document.getElementById('downloadResults').addEventListener('click', function() {
                downloadResults();
            });
            
            document.getElementById('newTest').addEventListener('click', function() {
                location.reload();
            });
            
            // Functions
            // Update the startLevel function for progressive difficulty
            function startLevel() {
                // Reset variables
                sequence = [];
                userSequence = [];
                attemptsPerLevel[currentLevel]++; // Track attempts for each level separately
                
                // Clear previous grid
                gridDiv.innerHTML = '';
                
                // Create grid
                const gridSize = gridSizes[currentLevel];
                const totalBoxes = gridSize * gridSize;
                
                // Update grid columns CSS for larger grids
                gridDiv.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
                
                for (let i = 0; i < totalBoxes; i++) {
                    const box = document.createElement('div');
                    box.className = 'box';
                    box.dataset.index = i;
                    gridDiv.appendChild(box);
                }
                
                // Progressive sequence length across 4 levels
                const sequenceLengths = [4, 5, 5, 6]; // Level 1: 4 numbers, Level 2: 5 numbers, Level 3: 5 numbers, Level 4: 6 numbers
                const boxCount = sequenceLengths[currentLevel];
                const numbers = Array.from({length: totalBoxes}, (_, i) => i);
                shuffleArray(numbers);
                sequence = numbers.slice(0, boxCount);
                
                // Update instructions
                instructionsP.textContent = `Level ${currentLevel + 1}: Remember the order of ${boxCount} numbers.`;
                
                // Hide buttons during display
                nextLevelBtn.classList.add('hidden');
                endTestBtn.classList.add('hidden');
                feedbackP.textContent = '';
                
                // Start displaying sequence after a delay
                setTimeout(displaySequence, 1000);
            }
            
            function displaySequence() {
                isDisplaying = true;
                let i = 0;
                
                const intervalId = setInterval(() => {
                    if (i > 0) {
                        // Clear previous number
                        const prevBox = gridDiv.children[sequence[i-1]];
                        prevBox.textContent = '';
                        prevBox.classList.remove('flash');
                    }
                    
                    if (i < sequence.length) {
                        // Show current number
                        const currentBox = gridDiv.children[sequence[i]];
                        currentBox.textContent = i + 1;
                        currentBox.classList.add('flash');
                        i++;
                    } else {
                        // End of sequence
                        clearInterval(intervalId);
                        setTimeout(() => {
                            // Clear last number
                            const lastBox = gridDiv.children[sequence[sequence.length-1]];
                            lastBox.textContent = '';
                            lastBox.classList.remove('flash');
                            
                            // Start recall phase
                            startRecall();
                        }, 500);
                    }
                }, 500);
            }
            
            function startRecall() {
                isDisplaying = false;
                isRecalling = true;
                userSequence = [];
                startTime = new Date();
                
                instructionsP.textContent = 'Now click the boxes in the same order they were numbered.';
                
                // Add click event listeners to boxes
                const boxes = gridDiv.children;
                for (let i = 0; i < boxes.length; i++) {
                    boxes[i].addEventListener('click', boxClickHandler);
                }
            }
            
            function boxClickHandler() {
                if (!isRecalling) return;
                
                const clickedIndex = parseInt(this.dataset.index);
                userSequence.push(clickedIndex);
                
                // Display the number in the clicked box
                this.textContent = userSequence.length;
                
                // Check if correct
                const expectedIndex = sequence[userSequence.length - 1];
                if (clickedIndex === expectedIndex) {
                    this.classList.add('correct');
                    
                    // Check if sequence complete
                    if (userSequence.length === sequence.length) {
                        endRecall(true);
                    }
                    // Removed the data saving during each correct click
                } else {
                    this.classList.add('incorrect');
                    endRecall(false);
                }
            }
            
            // Update endRecall to use level-specific attempts tracking
            function endRecall(success) {
                isRecalling = false;
                endTime = new Date();
                const responseTime = (endTime - startTime) / 1000; // in seconds
                
                // Remove click handlers
                const boxes = gridDiv.children;
                for (let i = 0; i < boxes.length; i++) {
                    boxes[i].removeEventListener('click', boxClickHandler);
                }
                
                // Get the current number of attempts for this level
                const currentLevelAttempts = attemptsPerLevel[currentLevel];
                
                // Calculate accuracy - only 1 if successful completion of the entire sequence, 0 otherwise
                const accuracy = success ? 1 : 0;
                
                // Record results for this attempt
                const resultEntry = {
                    participantId: document.getElementById('participantId').value,
                    musicalTraining: parseInt(document.getElementById('musicalTraining').value) || 0,
                    musicCondition: musicCondition,
                    level: currentLevel + 1,
                    gridSize: gridSizes[currentLevel],
                    sequenceLength: sequence.length,
                    responseTime: responseTime,
                    accuracy: accuracy,
                    attempt: currentLevelAttempts,
                    timestamp: new Date().toISOString()
                };
                
                // Add to results array
                results.push(resultEntry);
                
                // Save data after each level completion
                if (success) {
                    saveLevelResults(resultEntry);
                }
                
                // Show feedback
                if (success) {
                    feedbackP.textContent = `Success! Response time: ${responseTime.toFixed(2)} seconds. Attempts: ${currentLevelAttempts}. Data saved.`;
                    nextLevelBtn.classList.remove('hidden');
                } else {
                    feedbackP.textContent = `Incorrect sequence. Try again.`;
                    
                    // Allow retry or end test
                    if (currentLevelAttempts >= 100) {
                        feedbackP.textContent += ' Maximum attempts reached.';
                        endTestBtn.classList.remove('hidden');
                    } else {
                        setTimeout(startLevel, 2000);
                    }
                }
            }
            
            // New function to save results after each level completion
            function saveLevelResults(resultEntry) {
                // First, check if we have existing data
                let existingData = localStorage.getItem('memoryRecallLevelData');
                let dataArray = [];
                
                if (existingData) {
                    // Parse existing data
                    try {
                        dataArray = JSON.parse(existingData);
                    } catch(e) {
                        console.error('Error parsing stored level data', e);
                        dataArray = [];
                    }
                }
                
                // Add the new entry
                dataArray.push(resultEntry);
                
                // Store back to localStorage
                localStorage.setItem('memoryRecallLevelData', JSON.stringify(dataArray));
                
                // Also save the simplified version with just the required variables
                let simplifiedResult = {
                    ID: resultEntry.participantId,
                    'Music Type': resultEntry.musicCondition,
                    Level: resultEntry.level,
                    'Response Time': resultEntry.responseTime.toFixed(2),
                    Accuracy: resultEntry.accuracy
                };
                
                let existingSimplifiedData = localStorage.getItem('memoryRecallSimplifiedData');
                let simplifiedArray = [];
                
                if (existingSimplifiedData) {
                    try {
                        simplifiedArray = JSON.parse(existingSimplifiedData);
                    } catch(e) {
                        console.error('Error parsing stored simplified data', e);
                        simplifiedArray = [];
                    }
                }
                
                // Add the new simplified data
                simplifiedArray.push(simplifiedResult);
                
                // Store back to localStorage
                localStorage.setItem('memoryRecallSimplifiedData', JSON.stringify(simplifiedArray));
                
                // Provide auto-download option for the incremental data
                saveIncrementalDataToFile(resultEntry);
            }
            
            // Function to save incremental data to file
            function saveIncrementalDataToFile(resultEntry) {
                try {
                    // Get existing level data for this participant
                    let existingData = localStorage.getItem(`levelData_${resultEntry.participantId}`);
                    let levelStats = [];
                    
                    if (existingData) {
                        try {
                            levelStats = JSON.parse(existingData);
                        } catch(e) {
                            console.error('Error parsing stored level data', e);
                            levelStats = [];
                        }
                    }
                    
                    // Check if we already have an entry for this level
                    const existingLevelIndex = levelStats.findIndex(item => 
                        item.Level === resultEntry.level
                    );
                    
                    // If we have an existing entry for this level, update it
                    // Only if the current attempt was successful (accuracy = 1)
                    if (resultEntry.accuracy === 1) {
                        if (existingLevelIndex !== -1) {
                            // Update existing entry with successful attempt data
                            levelStats[existingLevelIndex].Attempts = resultEntry.attempt;
                            levelStats[existingLevelIndex]['Response Time'] = parseFloat(resultEntry.responseTime.toFixed(2));
                            levelStats[existingLevelIndex].Accuracy = resultEntry.accuracy;
                        } else {
                            // Add new entry for this level
                            levelStats.push({
                                ID: resultEntry.participantId,
                                'Music Type': resultEntry.musicCondition,
                                Level: resultEntry.level,
                                'Response Time': parseFloat(resultEntry.responseTime.toFixed(2)),
                                Accuracy: resultEntry.accuracy
                            });
                        }
                        
                        // Sort by level
                        levelStats.sort((a, b) => a.Level - b.Level);
                        
                        // Store the data back to localStorage
                        localStorage.setItem(`levelData_${resultEntry.participantId}`, JSON.stringify(levelStats));
                        
                        // Create CSV formatted string of the level data
                        const headers = "ID,Music Type,Level,Response Time,Accuracy";
                        const rows = levelStats.map(entry => {
                            return `${entry.ID},${entry['Music Type']},${entry.Level},${entry['Response Time']},${entry.Accuracy}`;
                        }).join('\n');
                        
                        const csvData = headers + '\n' + rows;
                        localStorage.setItem(`levelDataCSV_${resultEntry.participantId}`, csvData);
                        
                        // Create temporary notification with export option
                        const notification = document.createElement('div');
                        notification.style.position = 'fixed';
                        notification.style.bottom = '20px';
                        notification.style.right = '20px';
                        notification.style.backgroundColor = '#27ae60';
                        notification.style.color = 'white';
                        notification.style.padding = '15px';
                        notification.style.borderRadius = '5px';
                        notification.style.zIndex = '1000';
                        notification.style.boxShadow = '0 4px 6px rgba(0,0,0,0.1)';
                        notification.style.display = 'flex';
                        notification.style.flexDirection = 'column';
                        notification.style.gap = '10px';
                        
                        const messageDiv = document.createElement('div');
                        messageDiv.textContent = `Level ${resultEntry.level} completed with ${resultEntry.attempt} attempts! Data saved.`;
                        notification.appendChild(messageDiv);
                        
                        const exportBtn = document.createElement('button');
                        exportBtn.textContent = 'Export Data (CSV)';
                        exportBtn.style.backgroundColor = '#2980b9';
                        exportBtn.style.color = 'white';
                        exportBtn.style.border = 'none';
                        exportBtn.style.padding = '8px 12px';
                        exportBtn.style.borderRadius = '4px';
                        exportBtn.style.cursor = 'pointer';
                        
                        exportBtn.addEventListener('click', () => {
                            // Download the CSV data
                            const blob = new Blob([csvData], { type: 'text/csv' });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = `memory_recall_${resultEntry.participantId}_data.csv`;
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                            
                            // Add confirmation text
                            exportBtn.textContent = 'Downloaded!';
                            exportBtn.disabled = true;
                            exportBtn.style.backgroundColor = '#95a5a6';
                            
                            setTimeout(() => {
                                exportBtn.textContent = 'Export Data (CSV)';
                                exportBtn.disabled = false;
                                exportBtn.style.backgroundColor = '#2980b9';
                            }, 2000);
                        });
                        
                        notification.appendChild(exportBtn);
                        document.body.appendChild(notification);
                        
                        // Remove notification after 10 seconds (increased from 3 to give time to export)
                        setTimeout(() => {
                            if (document.body.contains(notification)) {
                                document.body.removeChild(notification);
                            }
                        }, 10000);
                    }
                } catch (e) {
                    console.error('Error saving level data', e);
                    
                    // Show error notification
                    const errorNotification = document.createElement('div');
                    errorNotification.textContent = `Error saving level data: ${e.message}`;
                    errorNotification.style.position = 'fixed';
                    errorNotification.style.bottom = '20px';
                    errorNotification.style.right = '20px';
                    errorNotification.style.backgroundColor = '#e74c3c';
                    errorNotification.style.color = 'white';
                    errorNotification.style.padding = '10px 15px';
                    errorNotification.style.borderRadius = '5px';
                    errorNotification.style.zIndex = '1000';
                    document.body.appendChild(errorNotification);
                    
                    // Remove error notification after 5 seconds
                    setTimeout(() => {
                        document.body.removeChild(errorNotification);
                    }, 5000);
                }
            }
            
            // Add the missing endTest function before it's referenced
            function endTest(quit = false, completed = false) {
                // Stop any audio playback
                if (backgroundMusic) {
                    backgroundMusic.pause();
                    backgroundMusic.currentTime = 0;
                }
                
                // Set global flags for results summary
                wasQuit = quit;
                allLevelsCompleted = completed;
                
                // Hide test area, show results
                testAreaDiv.classList.add('hidden');
                resultsDiv.classList.remove('hidden');
                
                // Generate and display results
                const summary = generateResultsSummary();
                if (!summary) {
                    resultsDiv.innerHTML = '<h2>Test Results</h2><p>No results to display.</p>';
                    return;
                }
                
                // Create readable summary
                let resultsHTML = `
                    <h3>Participant: ${summary.participantId}</h3>
                    <p><strong>Music Condition:</strong> ${summary.musicCondition}</p>
                    <p><strong>Prior Musical Training:</strong> ${summary.musicalTraining} years</p>
                    <p><strong>Test Status:</strong> ${summary.testStatus}</p>
                    <p><strong>Highest Level:</strong> ${summary.highestLevel}</p>
                    <p><strong>Overall Accuracy:</strong> ${summary.overallAccuracy}%</p>
                    <p><strong>Average Response Time:</strong> ${summary.averageResponseTime} seconds</p>
                    <h4>Level Statistics</h4>
                    <ul>
                `;
                
                // Add per-level stats
                for (let i = 1; i <= summary.highestLevel; i++) {
                    resultsHTML += `
                        <li>Level ${i}: 
                            Attempts: ${summary[`level${i}_attempts`]}, 
                            Accuracy: ${summary[`level${i}_accuracy`]}%, 
                            Avg Time: ${summary[`level${i}_avg_time`]} seconds
                        </li>
                    `;
                }
                
                resultsHTML += '</ul>';
                
                // Display the results
                document.getElementById('resultsContent').innerHTML = resultsHTML;
                
                // Save results to localStorage for future reference
                saveResultsToLocalStorage();
            }
            
            // Modify endTest to include the incremental data files in the download options
            const originalEndTest = endTest;
            endTest = function(quit = false, completed = false) {
                // Call the original endTest function
                originalEndTest(quit, completed);
                
                // Add download option for incremental data if available
                const participantId = document.getElementById('participantId').value;
                const incrementalData = localStorage.getItem(`incrementalData_${participantId}`);
                const incrementalSimplified = localStorage.getItem(`incrementalSimplified_${participantId}`);
                
                if (incrementalData || incrementalSimplified) {
                    // Create download buttons for incremental data
                    const datasetDiv = document.querySelector('#results div:last-child');
                    
                    if (incrementalData) {
                        const downloadIncrementalBtn = document.createElement('button');
                        downloadIncrementalBtn.textContent = 'Download Level-by-Level Data';
                        downloadIncrementalBtn.style.backgroundColor = '#3498db';
                        downloadIncrementalBtn.style.margin = '10px 5px';
                        downloadIncrementalBtn.addEventListener('click', function() {
                            downloadIncrementalData(participantId, incrementalData, 'full');
                        });
                        datasetDiv.appendChild(downloadIncrementalBtn);
                    }
                    
                    if (incrementalSimplified) {
                        const downloadSimplifiedIncrementalBtn = document.createElement('button');
                        downloadSimplifiedIncrementalBtn.textContent = 'Download Level-by-Level Required Variables';
                        downloadSimplifiedIncrementalBtn.style.backgroundColor = '#2ecc71';
                        downloadSimplifiedIncrementalBtn.style.margin = '10px 5px';
                        downloadSimplifiedIncrementalBtn.addEventListener('click', function() {
                            downloadIncrementalData(participantId, incrementalSimplified, 'simplified');
                        });
                        datasetDiv.appendChild(downloadSimplifiedIncrementalBtn);
                    }
                }
            };
            
            // Function to download incremental data
            function downloadIncrementalData(participantId, data, type) {
                const blob = new Blob([data], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `memory_recall_${type === 'full' ? 'full' : 'required'}_${participantId}_incremental_${new Date().toISOString().split('T')[0]}.csv`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
            
            // Replace the saveResultsToLocalStorage and related functions

            // Function to generate a single-row summary for each participant
            function generateResultsSummary() {
                if (results.length === 0) return null;
                
                const participantId = results[0].participantId;
                const musicCondition = results[0].musicCondition;
                const musicalTraining = results[0].musicalTraining;
                
                // Get highest level reached (1-based)
                const highestLevel = currentLevel + 1;
                
                // Calculate per-level statistics
                const levelStats = {};
                for (let i = 0; i < highestLevel; i++) {
                    const levelResults = results.filter(r => r.level === i + 1);
                    const levelAttempts = levelResults.length;
                    const levelSuccess = levelResults.filter(r => r.accuracy === 1).length;
                    const levelAccuracy = levelAttempts > 0 ? 
                        (levelSuccess / levelAttempts * 100).toFixed(2) : '0';
                    const levelAvgTime = levelAttempts > 0 ?
                        (levelResults.reduce((sum, r) => sum + r.responseTime, 0) / levelAttempts).toFixed(2) : '0';
                    
                    levelStats[`level${i+1}_attempts`] = levelAttempts;
                    levelStats[`level${i+1}_accuracy`] = levelAccuracy;
                    levelStats[`level${i+1}_avg_time`] = levelAvgTime;
                }
                
                // Calculate overall statistics
                const totalAttempts = results.length;
                const successfulAttempts = results.filter(r => r.accuracy === 1).length;
                const overallAccuracy = totalAttempts > 0 ? 
                    (successfulAttempts / totalAttempts * 100).toFixed(2) : '0';
                const averageResponseTime = totalAttempts > 0 ? 
                    (results.reduce((sum, r) => sum + r.responseTime, 0) / totalAttempts).toFixed(2) : '0';
                
                const summary = {
                    participantId: participantId,
                    timestamp: new Date().toISOString(),
                    musicCondition: musicCondition,
                    musicalTraining: musicalTraining,
                    highestLevel: highestLevel,
                    testStatus: wasQuit ? 'quit' : (allLevelsCompleted ? 'completed' : 'max_attempts'),
                    totalAttempts: totalAttempts,
                    successfulAttempts: successfulAttempts,
                    overallAccuracy: overallAccuracy,
                    averageResponseTime: averageResponseTime,
                    ...levelStats
                };
                
                // Create a simplified level-by-level summary for easy downloading after each level
                const levelSummaries = [];
                for (let i = 0; i < highestLevel; i++) {
                    const levelResults = results.filter(r => r.level === i + 1);
                    if (levelResults.length > 0) {
                        const levelSuccess = levelResults.filter(r => r.accuracy === 1).length;
                        const levelAccuracy = (levelSuccess / levelResults.length * 100).toFixed(2);
                        const levelAvgTime = (levelResults.reduce((sum, r) => sum + r.responseTime, 0) / levelResults.length).toFixed(2);
                        
                        levelSummaries.push({
                            participantId: participantId,
                            level: i + 1,
                            musicCondition: musicCondition,
                            musicalTraining: musicalTraining,
                            gridSize: gridSizes[i],
                            attempts: levelResults.length,
                            success: levelSuccess,
                            accuracy: levelAccuracy,
                            averageResponseTime: levelAvgTime,
                            timestamp: new Date().toISOString()
                        });
                    }
                }
                
                // Store level summaries in localStorage for easier access
                localStorage.setItem(`levelSummaries_${participantId}`, JSON.stringify(levelSummaries));
                
                return summary;
            }
            
            function saveResultsToLocalStorage() {
                const summary = generateResultsSummary();
                if (!summary) return;
                
                // First, check if we have existing data
                let existingData = localStorage.getItem('memoryRecallSummaryData');
                let dataArray = [];
                
                if (existingData) {
                    // Parse existing data
                    try {
                        dataArray = JSON.parse(existingData);
                    } catch(e) {
                        console.error('Error parsing stored data', e);
                        dataArray = [];
                    }
                }
                
                // Add the new summary
                dataArray.push(summary);
                
                // Store back to localStorage
                localStorage.setItem('memoryRecallSummaryData', JSON.stringify(dataArray));
                localStorage.setItem('memoryRecallParticipantCount', dataArray.length);
                
                // Also save the simplified data with just the requested variables
                const simplifiedData = generateSimplifiedResults();
                if (simplifiedData && simplifiedData.length > 0) {
                    let existingSimplifiedData = localStorage.getItem('memoryRecallSimplifiedData');
                    let simplifiedArray = [];
                    
                    if (existingSimplifiedData) {
                        try {
                            simplifiedArray = JSON.parse(existingSimplifiedData);
                        } catch(e) {
                            console.error('Error parsing stored simplified data', e);
                            simplifiedArray = [];
                        }
                    }
                    
                    // Add the new simplified data
                    simplifiedArray = simplifiedArray.concat(simplifiedData);
                    
                    // Store back to localStorage
                    localStorage.setItem('memoryRecallSimplifiedData', JSON.stringify(simplifiedArray));
                }
                
                // Show feedback
                const savedMessage = document.createElement('p');
                savedMessage.textContent = `Results saved! Total saved participants: ${dataArray.length}`;
                savedMessage.style.color = 'green';
                resultsDiv.appendChild(savedMessage);
                
                // Return the CSV version of this single row
                return convertSummaryToCSV(summary);
            }
            
            function convertSummaryToCSV(summary) {
                // Get all headers from the summary object
                const headers = Object.keys(summary);
                
                // Generate CSV header row and data row
                const headerRow = headers.join(',');
                const dataRow = headers.map(key => {
                    // Wrap string values in quotes to handle commas in strings
                    if (typeof summary[key] === 'string' && summary[key].includes(',')) {
                        return `"${summary[key]}"`;
                    }
                    return summary[key];
                }).join(',');
                
                return {
                    headers: headerRow,
                    data: dataRow,
                    full: headerRow + '\n' + dataRow
                };
            }
            
            function downloadResults() {
                // Force a save and get the CSV data
                const csvData = saveResultsToLocalStorage();
                if (!csvData) {
                    alert("No results to download");
                    return;
                }
                
                // Create download link for the current session
                const blob = new Blob([csvData.full], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `memory_recall_${results[0].participantId}_${new Date().toISOString().split('T')[0]}.csv`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                // Also offer to download the full dataset if not already present
                if (!document.querySelector('[data-action="download-full"]')) {
                    const downloadFullDataBtn = document.createElement('button');
                    downloadFullDataBtn.textContent = 'Download Full Dataset';
                    downloadFullDataBtn.dataset.action = 'download-full';
                    downloadFullDataBtn.addEventListener('click', downloadFullDataset);
                    resultsDiv.appendChild(downloadFullDataBtn);
                }
            }
            
            function downloadFullDataset() {
                // Get the stored data
                const storedData = localStorage.getItem('memoryRecallSummaryData');
                
                if (!storedData) {
                    alert('No saved data found');
                    return;
                }
                
                try {
                    const dataArray = JSON.parse(storedData);
                    if (dataArray.length === 0) {
                        alert('No saved data found');
                        return;
                    }
                    
                    // Get headers from the first item
                    const headers = Object.keys(dataArray[0]).join(',');
                    
                    // Map each summary object to a CSV row
                    const rows = dataArray.map(summary => {
                        return Object.keys(dataArray[0]).map(key => {
                            const value = summary[key] || '';
                            // Wrap string values in quotes to handle commas in strings
                            if (typeof value === 'string' && value.includes(',')) {
                                return `"${value}"`;
                            }
                            return value;
                        }).join(',');
                    }).join('\n');
                    
                    // Combine headers and rows
                    const csv = headers + '\n' + rows;
                    
                    // Create and trigger download
                    const blob = new Blob([csv], { type: 'text/csv' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `memory_recall_full_dataset_${new Date().toISOString().split('T')[0]}.csv`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } catch(e) {
                    console.error('Error processing stored data', e);
                    alert('Error processing the stored data');
                }
            }
            
            function viewStoredDataset() {
                const storedData = localStorage.getItem('memoryRecallSummaryData');
                
                if (!storedData) {
                    alert('No saved data found');
                    return;
                }
                
                try {
                    const dataArray = JSON.parse(storedData);
                    if (dataArray.length === 0) {
                        alert('No saved data found');
                        return;
                    }
                    
                    // Get headers from the first item
                    const headers = Object.keys(dataArray[0]).join(',');
                    
                    // Map each summary object to a CSV row
                    const rows = dataArray.map(summary => {
                        return Object.keys(dataArray[0]).map(key => {
                            const value = summary[key] || '';
                            // Wrap string values in quotes to handle commas in strings
                            if (typeof value === 'string' && value.includes(',')) {
                                return `"${value}"`;
                            }
                            return value;
                        }).join(',');
                    }).join('\n');
                    
                    // Combine headers and rows for display
                    const csv = headers + '\n' + rows;
                    
                    // Create a modal to display the data
                    const modal = document.createElement('div');
                    modal.style.position = 'fixed';
                    modal.style.top = '0';
                    modal.style.left = '0';
                    modal.style.width = '100%';
                    modal.style.height = '100%';
                    modal.style.backgroundColor = 'rgba(0,0,0,0.7)';
                    modal.style.zIndex = '1000';
                    modal.style.display = 'flex';
                    modal.style.justifyContent = 'center';
                    modal.style.alignItems = 'center';
                    
                    const content = document.createElement('div');
                    content.style.backgroundColor = 'white';
                    content.style.padding = '20px';
                    content.style.borderRadius = '5px';
                    content.style.maxWidth = '80%';
                    content.style.maxHeight = '80%';
                    content.style.overflow = 'auto';
                    
                    const closeBtn = document.createElement('button');
                    closeBtn.textContent = 'Close';
                    closeBtn.addEventListener('click', function() {
                        document.body.removeChild(modal);
                    });
                    
                    const downloadBtn = document.createElement('button');
                    downloadBtn.textContent = 'Download Full Dataset';
                    downloadBtn.addEventListener('click', downloadFullDataset);
                    
                    const pre = document.createElement('pre');
                    pre.style.whiteSpace = 'pre-wrap';
                    pre.textContent = csv;
                    
                    content.appendChild(closeBtn);
                    content.appendChild(downloadBtn);
                    content.appendChild(document.createElement('hr'));
                    content.appendChild(pre);
                    modal.appendChild(content);
                    
                    document.body.appendChild(modal);
                } catch(e) {
                    console.error('Error processing stored data', e);
                    alert('Error processing the stored data');
                }
            }
            
            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }
            
            // Function to generate simplified results with just the requested variables
            function generateSimplifiedResults() {
                const simplifiedResults = results.map(r => ({
                    ID: r.participantId,
                    'Music Type': r.musicCondition,
                    Level: r.level,
                    'Response Time': r.responseTime.toFixed(2),
                    Accuracy: r.accuracy
                }));
                
                // Add download button specifically for simplified data
                const downloadSimplifiedBtn = document.createElement('button');
                downloadSimplifiedBtn.textContent = 'Download Required Variables';
                downloadSimplifiedBtn.style.backgroundColor = '#27ae60';
                downloadSimplifiedBtn.style.margin = '10px 5px';
                downloadSimplifiedBtn.addEventListener('click', function() {
                    downloadSimplifiedResults(simplifiedResults);
                });
                
                // Add button to results div after it becomes visible
                setTimeout(() => {
                    if (!document.querySelector('[data-action="download-simplified"]')) {
                        downloadSimplifiedBtn.dataset.action = 'download-simplified';
                        resultsDiv.appendChild(downloadSimplifiedBtn);
                    }
                }, 100);
                
                return simplifiedResults;
            }
            
            // Function to download just the simplified results
            function downloadSimplifiedResults(simplifiedResults) {
                if (!simplifiedResults || simplifiedResults.length === 0) {
                    alert("No results to download");
                    return;
                }
                
                // Create CSV header from the first result's keys
                const headers = Object.keys(simplifiedResults[0]).join(',');
                
                // Create CSV rows from the data
                const rows = simplifiedResults.map(result => {
                    return Object.values(result).map(value => {
                        // Handle commas in string values
                        if (typeof value === 'string' && value.includes(',')) {
                            return `"${value}"`;
                        }
                        return value;
                    }).join(',');
                }).join('\n');
                
                // Combine headers and rows
                const csv = headers + '\n' + rows;
                
                // Create download link
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `memory_recall_required_vars_${simplifiedResults[0].ID}_${new Date().toISOString().split('T')[0]}.csv`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                // Show confirmation
                alert("Required variables (ID, Music Type, Level, Response Time, Accuracy) have been downloaded.");
            }
        });
    </script>
</body>
</html>